<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fancy Flight Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: lime;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #resetButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #resetButton:hover {
            background: rgba(255, 0, 0, 1);
        }
    </style>
</head>
<body>
    <div id="hud">
        <div>Altitude: <span id="altitude">0</span> m</div>
        <div>Speed: <span id="speed">0</span> m/s</div>
        <div>Pitch: <span id="pitch">0</span>°</div>
        <div>Yaw: <span id="yaw">0</span>°</div>
        <div>Roll: <span id="roll">0</span>°</div>
        <div>Instructions: Click to lock mouse, WASD for pitch/yaw, Arrows for roll/throttle, Space to boost</div>
    </div>
    <button id="resetButton">Reset</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script type="module">
        // Import PointerLockControls
        import { PointerLockControls } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/examples/jsm/controls/PointerLockControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Mouse look controls
        const pointerLockControls = new PointerLockControls(camera, renderer.domElement);
        scene.add(pointerLockControls.getObject());
        document.addEventListener('click', () => {
            pointerLockControls.lock();
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Skybox
        const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0xb0e0e6, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x4682b4, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide })
        ];
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);

        // Terrain
        const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
        const terrainMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, wireframe: false });
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -50;
        const positionAttribute = terrainGeometry.attributes.position;
        const terrainHeights = new Float32Array(positionAttribute.count);
        for (let i = 2; i < positionAttribute.count * 3; i += 3) {
            const height = Math.random() * 10;
            positionAttribute.array[i] = height;
            terrainHeights[i / 3] = height - 50;
        }
        positionAttribute.needsUpdate = true;
        scene.add(terrain);

        // Airplane (detailed model)
        const airplaneGroup = new THREE.Group();
        // Fuselage
        const fuselageGeometry = new THREE.CylinderGeometry(0.8, 0.8, 8, 32);
        const airplaneMaterial = new THREE.MeshStandardMaterial({ color: 0x4682b4 });
        const fuselage = new THREE.Mesh(fuselageGeometry, airplaneMaterial);
        fuselage.rotation.z = Math.PI / 2;
        airplaneGroup.add(fuselage);
        // Wings
        const wingsGeometry = new THREE.BoxGeometry(12, 0.2, 3);
        const wings = new THREE.Mesh(wingsGeometry, airplaneMaterial);
        wings.position.y = 0.5;
        airplaneGroup.add(wings);
        // Tail wings
        const tailWingsGeometry = new THREE.BoxGeometry(4, 0.2, 1.5);
        const tailWings = new THREE.Mesh(tailWingsGeometry, airplaneMaterial);
        tailWings.position.set(-3.5, 0.5, 0);
        airplaneGroup.add(tailWings);
        // Vertical stabilizer
        const verticalStabGeometry = new THREE.BoxGeometry(0.2, 2, 2);
        const verticalStab = new THREE.Mesh(verticalStabGeometry, airplaneMaterial);
        verticalStab.position.set(-3.5, 1.5, 0);
        airplaneGroup.add(verticalStab);
        // Cockpit
        const cockpitGeometry = new THREE.SphereGeometry(0.8, 32, 16, 0, Math.PI);
        const cockpit = new THREE.Mesh(cockpitGeometry, new THREE.MeshStandardMaterial({ color: 0x333333 }));
        cockpit.position.set(3.5, 0.5, 0);
        cockpit.rotation.y = Math.PI;
        airplaneGroup.add(cockpit);
        // Engines (simple cylinders)
        const engineGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
        const engine1 = new THREE.Mesh(engineGeometry, airplaneMaterial);
        engine1.position.set(0, 0.2, -1.8);
        airplaneGroup.add(engine1);
        const engine2 = new THREE.Mesh(engineGeometry, airplaneMaterial);
        engine2.position.set(0, 0.2, 1.8);
        airplaneGroup.add(engine2);

        airplaneGroup.position.set(0, 10, 0);
        scene.add(airplaneGroup);

        // Camera setup (attached to airplane)
        camera.position.set(0, 2, 5); // Inside cockpit view
        airplaneGroup.add(camera);

        // Physics and controls
        let velocity = new THREE.Vector3(0, 0, 0.1);
        let pitch = 0, yaw = 0, roll = 0;
        let speed = 0.1;
        const maxSpeed = 0.5;
        const gravity = -0.002;
        const controls = {
            pitchUp: false,
            pitchDown: false,
            yawLeft: false,
            yawRight: false,
            rollLeft: false,
            rollRight: false,
            accelerate: false,
            decelerate: false,
            boost: false
        };

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w': controls.pitchUp = true; break;
                case 's': controls.pitchDown = true; break;
                case 'a': controls.yawLeft = true; break;
                case 'd': controls.yawRight = true; break;
                case 'ArrowLeft': controls.rollLeft = true; break;
                case 'ArrowRight': controls.rollRight = true; break;
                case 'ArrowUp': controls.accelerate = true; break;
                case 'ArrowDown': controls.decelerate = true; break;
                case ' ': controls.boost = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'w': controls.pitchUp = false; break;
                case 's': controls.pitchDown = false; break;
                case 'a': controls.yawLeft = false; break;
                case 'd': controls.yawRight = false; break;
                case 'ArrowLeft': controls.rollLeft = false; break;
                case 'ArrowRight': controls.rollRight = false; break;
                case 'ArrowUp': controls.accelerate = false; break;
                case 'ArrowDown': controls.decelerate = false; break;
                case ' ': controls.boost = false; break;
            }
        });

        // Reset button
        const resetButton = document.getElementById('resetButton');
        resetButton.addEventListener('click', () => {
            airplaneGroup.position.set(0, 10, 0);
            airplaneGroup.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0.1);
            pitch = 0;
            yaw = 0;
            roll = 0;
            speed = 0.1;
            pointerLockControls.getObject().position.set(0, 2, 5);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            if (controls.pitchUp) pitch += 0.02;
            if (controls.pitchDown) pitch -= 0.02;
            if (controls.yawLeft) yaw += 0.02;
            if (controls.yawRight) yaw -= 0.02;
            if (controls.rollLeft) roll += 0.02;
            if (controls.rollRight) roll -= 0.02;
            if (controls.accelerate) speed = Math.min(speed + 0.005, maxSpeed);
            if (controls.decelerate) speed = Math.max(speed - 0.005, 0);
            if (controls.boost) speed = Math.min(speed + 0.01, maxSpeed);

            // Apply rotations
            airplaneGroup.rotation.order = 'ZYX';
            airplaneGroup.rotation.x = pitch;
            airplaneGroup.rotation.y = yaw;
            airplaneGroup.rotation.z = roll;

            // Update velocity based on orientation
            const direction = new THREE.Vector3(0, 0, 1).applyQuaternion(airplaneGroup.quaternion);
            velocity.copy(direction.multiplyScalar(speed));

            // Apply gravity
            velocity.y += gravity;

            // Update position
            airplaneGroup.position.add(velocity);

            // Terrain collision detection
            const gridX = Math.floor((airplaneGroup.position.x + 500) / 20);
            const gridZ = Math.floor((airplaneGroup.position.z + 500) / 20);
            const vertexIndex = gridZ * 51 + gridX;
            const terrainHeight = vertexIndex >= 0 && vertexIndex < terrainHeights.length ? terrainHeights[vertexIndex] : -50;
            if (airplaneGroup.position.y < terrainHeight + 2) {
                airplaneGroup.position.y = terrainHeight + 2;
                velocity.y = Math.max(velocity.y, 0);
            }

            // Update HUD
            document.getElementById('altitude').textContent = airplaneGroup.position.y.toFixed(1);
            document.getElementById('speed').textContent = (speed * 100).toFixed(1);
            document.getElementById('pitch').textContent = (pitch * 180 / Math.PI).toFixed(1);
            document.getElementById('yaw').textContent = (yaw * 180 / Math.PI).toFixed(1);
            document.getElementById('roll').textContent = (roll * 180 / Math.PI).toFixed(1);

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
